void matrix_by_matrix(int row, int collumn,float arr[row][collumn], int row1, int collumn1, float arr1[10][10]){
    float resultant[10][10];
    int result = 0;
    if(collumn != row1)
        {
            printf("\nThe rows of the first matrix and the colums of the second matrix have to be the same, try again.\n");
            return;
        }
    for(int i = 0; i < row; i++)
    {
        for(int j = 0; j < collumn1; j++)
        {
            for(int p = 0; p < row1; p++)
            {
                result += arr[i][p] * arr1[p][j];
            }
            resultant[i][j] = result;
            result = 0;
        }
    }
    printf("Resultant:\n");
    for(int i = 0; i < row; i++)
    {
        for(int j = 0; j < collumn1; j++)
        {
            printf("%f ", resultant[i][j]);
        }
        printf("\n");
    }
}
float find_determinant(int row, float a[row][row]){
    float det;
    if (row == 1){
        det = a[0][0];
    }
    if(row == 2)
    {
        det = a[0][0]*a[1][1] - a[0][1]*a[1][0];
    }
    else if(row == 3)
    {
        det = a[0][0]*a[1][1]*a[2][2] + a[1][0]*a[2][1]*a[0][2] + a[0][1]*a[1][2]*a[2][0] - a[0][2]*a[1][1]*a[2][0] - a[1][0]*a[0][1]*a[2][2] - a[1][2]*a[2][1]*a[0][0];
    }
    else if(row == 4)
    {
        det = (a[1][1]*a[2][2]*a[3][3] + a[2][1]*a[3][2]*a[1][3] + a[1][2]*a[2][3]*a[3][1] - a[1][3]*a[2][2]*a[3][1] - a[3][2]*a[2][3]*a[1][1] - a[2][1]*a[1][2]*a[3][3]) * a[0][0]
        - (a[0][1]*a[2][2]*a[3][3] + a[2][1]*a[3][2]*a[0][3] + a[0][2]*a[2][3]*a[3][1] - a[0][3]*a[2][2]*a[3][1] - a[2][3]*a[3][2]*a[0][1] - a[0][2]*a[2][1]*a[3][3]) * a[1][0]
        + (a[0][1]*a[1][2]*a[3][3] + a[1][1]*a[3][2]*a[0][3] + a[0][2]*a[1][3]*a[3][1] - a[0][3]*a[1][2]*a[3][1] - a[1][3]*a[3][2]*a[0][1] - a[0][2]*a[1][1]*a[3][3]) * a[2][0]
        - (a[0][1]*a[1][2]*a[2][3] + a[1][1]*a[2][2]*a[0][3] + a[0][2]*a[1][3]*a[2][1] - a[0][3]*a[1][2]*a[2][1] - a[1][3]*a[2][2]*a[0][1] - a[0][2]*a[1][1]*a[2][3]) * a[3][0];
    }
    printf("The determinant of this %d x %d matrix is %f.\n", row, row, det);
    return det;
}
 void inverse_matrix(int row, float a[row][row]){
    int i, j, k;
    float tp;
    float tmpr;
    float det = find_determinant(row, a);
    float inv[row][row];
    float res[row][row];
    if(det == 0)
    {
        printf("\nThe inverse matrix doesn't exist since the determinant is equal to 0.");
        return;
    }
    if(row<1 || row>4){
        printf("The rows and columns have to be a number between 1 and 4, try again.");
        return;
    }
    if(row == 1)
    {
        if(a[0][0] == 0)
        {
            printf("A 1x1 matrix with an element 0 cannot have an inverse matrix, try again.");
            return;
        }
        else
        {
        inv[0][0] = 1/a[0][0];
        }
    }

    if(row == 2)
    {
        res[0][0] = a[1][1];
        res[0][1] = a[0][1] * -1;
        res[1][0] = a[1][0] * -1;
        res[1][1] = a[0][0];

        det = 1.0 / det;

        for(i = 0; i < 2; i++)
        {
            for(j = 0; j < 2; j++)
            {
               inv[i][j] = res[i][j] * det;
            }
        }
    }

    if(row == 3)
    {
        //formula-a[(i+1)%3][(j+1)%3] * a[(i+2)%3][(j+2)%3]) - (a[(i+1)%3][(j+2)%3]*a[(i+2)%3][(j+1)%3]
        res[0][0] = a[1][1] * a[2][2] - a[2][1] * a[1][2];
        res[0][1] = a[0][2] * a[2][1] - a[0][1] * a[2][2];
        res[0][2] = a[0][1] * a[1][2] - a[0][2] * a[1][1];
        res[1][0] = a[1][2] * a[2][0] - a[1][0] * a[2][2];
        res[1][1] = a[0][0] * a[2][2] - a[0][2] * a[2][0];
        res[1][2] = a[1][0] * a[0][2] - a[0][0] * a[1][2];
        res[2][0] = a[1][0] * a[2][1] - a[2][0] * a[1][1];
        res[2][1] = a[2][0] * a[0][1] - a[0][0] * a[2][1];
        res[2][2] = a[0][0] * a[1][1] - a[1][0] * a[0][1];

        det = 1.0 / det;

        for(i = 0; i < 3; i++)
        {
            for(j = 0; j < 3; j++)
            {
               inv[i][j] = res[i][j] * det;
            }
        }

    }


    if(row == 4)
    {
        res[0][0]  =  a[1][1] * a[2][2] * a[3][3] - a[1][1] * a[2][3] * a[3][2] - a[2][1] * a[1][2] * a[3][3] + a[2][1] * a[1][3] * a[3][2] + a[3][1] * a[1][2] * a[2][3] - a[3][1] * a[1][3] * a[2][2];
        res[0][1]  = -a[0][1] * a[2][2] * a[3][3] + a[0][1] * a[2][3] * a[3][2] + a[2][1] * a[0][2] * a[3][3] - a[2][1] * a[0][3] * a[3][2] - a[3][1] * a[0][2] * a[2][3] + a[3][1] * a[0][3] * a[2][2];
        res[0][2]  =  a[0][1] * a[1][2]  * a[3][3] - a[0][1] * a[1][3]  * a[3][2] - a[1][1] * a[0][2] * a[3][3] + a[1][1] * a[0][3] * a[3][2] + a[3][1] * a[0][2] * a[1][3]  - a[3][1] * a[0][3] * a[1][2];
        res[0][3]  = -a[0][1] * a[1][2]  * a[2][3] + a[0][1] * a[1][3]  * a[2][2] + a[1][1] * a[0][2] * a[2][3] - a[1][1] * a[0][3] * a[2][2] - a[2][1]  * a[0][2] * a[1][3]  + a[2][1]  * a[0][3] * a[1][2];
        res[1][0]  = -a[1][0] * a[2][2] * a[3][3] + a[1][0] * a[2][3] * a[3][2] + a[2][0] * a[1][2] * a[3][3] - a[2][0] * a[1][3] * a[3][2] - a[3][0] * a[1][2] * a[2][3] + a[3][0] * a[1][3] * a[2][2];
        res[1][1]  =  a[0][0] * a[2][2] * a[3][3] - a[0][0] * a[2][3] * a[3][2] - a[2][0] * a[0][2] * a[3][3] + a[2][0] * a[0][3] * a[3][2] + a[3][0] * a[0][2] * a[2][3] - a[3][0] * a[0][3] * a[2][2];
        res[1][2]  = -a[0][0] * a[1][2]  * a[3][3] + a[0][0] * a[1][3]  * a[3][2] + a[1][0] * a[0][2] * a[3][3] - a[1][0] * a[0][3] * a[3][2] - a[3][0] * a[0][2] * a[1][3]  + a[3][0] * a[0][3] * a[1][2];
        res[1][3]  =  a[0][0] * a[1][2]  * a[2][3] - a[0][0] * a[1][3]  * a[2][2] - a[1][0] * a[0][2] * a[2][3] + a[1][0] * a[0][3] * a[2][2] + a[2][0]  * a[0][2] * a[1][3]  - a[2][0]  * a[0][3] * a[1][2];
        res[2][0]  =  a[1][0] * a[2][1]  * a[3][3] - a[1][0] * a[2][3] * a[3][1] - a[2][0] * a[1][1] * a[3][3] + a[2][0] * a[1][3] * a[3][1] + a[3][0] * a[1][1] * a[2][3] - a[3][0] * a[1][3] * a[2][1];
        res[2][1]  = -a[0][0] * a[2][1]  * a[3][3] + a[0][0] * a[2][3] * a[3][1] + a[2][0] * a[0][1] * a[3][3] - a[2][0] * a[0][3] * a[3][1] - a[3][0] * a[0][1] * a[2][3] + a[3][0] * a[0][3] * a[2][1];
        res[2][2] =  a[0][0] * a[1][1]  * a[3][3] - a[0][0] * a[1][3]  * a[3][1] - a[1][0] * a[0][1] * a[3][3] + a[1][0] * a[0][3] * a[3][1] + a[3][0] * a[0][1] * a[1][3]  - a[3][0] * a[0][3] * a[1][1];
        res[2][3] = -a[0][0] * a[1][1]  * a[2][3] + a[0][0] * a[1][3]  * a[2][1]  + a[1][0] * a[0][1] * a[2][3] - a[1][0] * a[0][3] * a[2][1]  - a[2][0]  * a[0][1] * a[1][3]  + a[2][0]  * a[0][3] * a[1][1];
        res[3][0] = -a[1][0] * a[2][1]  * a[3][2] + a[1][0] * a[2][2] * a[3][1] + a[2][0] * a[1][1] * a[3][2] - a[2][0] * a[1][2] * a[3][1] - a[3][0] * a[1][1] * a[2][2] + a[3][0] * a[1][2] * a[2][1];
        res[3][1] =  a[0][0] * a[2][1]  * a[3][2] - a[0][0] * a[2][2] * a[3][1] - a[2][0] * a[0][1] * a[3][2] + a[2][0] * a[0][2] * a[3][1] + a[3][0] * a[0][1] * a[2][2] - a[3][0] * a[0][2] * a[2][1];
        res[3][2] = -a[0][0] * a[1][1]  * a[3][2] + a[0][0] * a[1][2]  * a[3][1] + a[1][0] * a[0][1] * a[3][2] - a[1][0] * a[0][2] * a[3][1] - a[3][0] * a[0][1] * a[1][2]  + a[3][0] * a[0][2] * a[1][1];
        res[3][3] =  a[0][0] * a[1][1]  * a[2][2] - a[0][0] * a[1][2]  * a[2][1]  - a[1][0] * a[0][1] * a[2][2] + a[1][0] * a[0][2] * a[2][1]  + a[2][0]  * a[0][1] * a[1][2]  - a[2][0]  * a[0][2] * a[1][1];

        det = 1.0 / det;

        for(i = 0; i < 4; i++)
        {
            for(j = 0; j < 4; j++)
            {
               inv[i][j] = res[i][j] * det;
            }
        }

    }
    printf("\nThe inversed matrix is:\n");
    for(i = 0; i < row; i++)
    {
        for(j = 0; j < row; j++)
        {
            printf("%.3f", inv[i][j]);
            printf("\t");
        }
        printf("\n");
    }
 }